'''
Joe Walter

difficulty: 40%
run time:   0:00
answer:     28.2453753155

	***

395 Pythagorean Tree

The Pythagorean tree is a fractal generated by the following procedure:

Start with a unit square. Then, calling one of the sides its base (in the animation, the bottom side is the base):

    1. Attach a right triangle to the side opposite the base, with the hypotenuse coinciding with that side and with the sides in a 3-4-5 ratio. Note that the smaller side of the triangle must be on the 'right' side with respect to the base (see animation).
    2. Attach a square to each leg of the right triangle, with one of its sides coinciding with that leg.
    3. Repeat this procedure for both squares, considering as their bases the sides touching the triangle.

The resulting figure, after an infinite number of iterations, is the Pythagorean tree.

https://projecteuler.net/resources/images/0395_pythagorean.gif?1678992056

It can be shown that there exists at least one rectangle, whose sides are parallel to the largest square of the Pythagorean tree, which encloses the Pythagorean tree completely.

Find the smallest area possible for such a bounding rectangle, and give your answer rounded to 10 decimal places.
'''

from math import pi, sin, cos, atan, sqrt, acos

DEPTH = 8         # how far to look ahead before choosing a move
PREC  = 10**-15   # stop when movements are below this threshold

a,b,c = 3,4,5                     # side lengths, in ascending order
#a,b,c = 5/sqrt(2), 5/sqrt(2), 5  # isosceles (area should be exactly 6*4=24)
#a,b,c = 119,120,169              # almost isosceles (area should be close to 24)

# the c square is a unit square
a,b,c = a/c, b/c, 1

# no change
'''
from mpmath import *
mp.dps = 25
a,b,c = mpf(3),mpf(4),mpf(5)
DEPTH = 12
PREC  = 10**-20
#'''

# constants for calculating coordinates of smaller squares relative to bigger one
Lx = (-c/2 + b/2*sqrt(2)*cos(pi/4 + atan(a/b)) )/c
Ly = ( c/2 + b/2*sqrt(2)*sin(pi/4 + atan(a/b)) )/c
Rx = ( c/2 - a/2*sqrt(2)*cos(pi/4 + atan(b/a)) )/c
Ry = ( c/2 + a/2*sqrt(2)*sin(pi/4 + atan(b/a)) )/c
Lr =  atan(a/b)
Rr = -atan(b/a)

def next(square):
	x, y, scale, rot = square
	cs, sn = cos(rot), sin(rot)
	# scale and rotate change in coordinates
	dLx, dLy = scale*(cs*Lx - sn*Ly), scale*(sn*Lx + cs*Ly)
	dRx, dRy = scale*(cs*Rx - sn*Ry), scale*(sn*Rx + cs*Ry)
	# "Left" and "Right" squares
	L = (x + dLx, y + dLy, scale*b/c, rot + Lr)
	R = (x + dRx, y + dRy, scale*a/c, rot + Rr)
	return L, R

# directions to travel by maximizing coordinate value
left_dir  = lambda s: -s[0]
up_dir    = lambda s:  s[1]
right_dir = lambda s:  s[0]
down_dir  = lambda s: -s[1]

def choose(square, direction):
	L, R = next(square)
	Ls, Rs = [L], [R]
	for _ in range(DEPTH-1):
		_Ls, _Rs = [], []
		for s in Ls:
			_Ls += list(next(s))
		for s in Rs:
			_Rs += list(next(s))
		Ls, Rs = _Ls, _Rs
	if max(direction(s) for s in Ls) > max(direction(s) for s in Rs):
		print("L", end="")
		return L
	else:
		print("R", end="")
		return R

def farthest(s, direction):
	while s[2] >= PREC:
		s = choose(s, direction)
	print()
	print(s)
	print()
	return direction(s)

# origin is bottom left corner of largest square
start = (c/2, c/2, c, 0)

print("← ", end="")
left  = farthest(start, left_dir)
print("↑ ", end="")
up    = farthest(start, up_dir)
print("→ ", end="")
right = farthest(start, right_dir)

# This possibly won't work if one "child" square is *much* smaller than the other
#downL = farthest(next(start)[0], down_dir)
#downR = farthest(next(start)[1], down_dir)

downL = start
print("↓ ", end="")
while not (pi/2 <= downL[3] % (2*pi) <= 3*pi/2):
	print("L", end="")
	downL = next(downL)[0]
downL = farthest(downL, down_dir)

downR = start
print("↓ ", end="")
while not (pi/2 <= downR[3] % (2*pi) <= 3*pi/2):
	print("R", end="")
	downR = next(downR)[1]
downR = farthest(downR, down_dir)

down  = max(0, downL, downR)

h = up   + down
w = left + right

print(f"{left  = }")
print(f"{up    = }")
print(f"{right = }")
print(f"{downL = }")
print(f"{downR = }")
print(f"{down  = }")
print()

print(f"{h = }")
print(f"{w = }")
print()

print(f"{h*w = :.10f}")
