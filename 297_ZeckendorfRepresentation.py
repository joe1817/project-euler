'''
Joe Walter

difficulty: 35%
run time:   0:00
answer:     2252639041804718029

	***

297 Zeckendorf Representation

Each new term in the Fibonacci sequence is generated by adding the previous two terms.

Starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89.

Every positive integer can be uniquely written as a sum of nonconsecutive terms of the Fibonacci sequence. For example, 100 = 3 + 8 + 89.

Such a sum is called the Zeckendorf representation of the number.

For any integer n>0, let z(n) be the number of terms in the Zeckendorf representation of n.

Thus, z(5)=1, z(14)=2, z(100)=3 etc.

Also, for 0<n<10^6, ∑z(n)=7894453.

Find ∑z(n) for 0<n<10^17.

	***

Observations

Zeckendorf Representations can be nicely visualized in ascending order using rectangles with Fibonacci side lengths. See https://en.wikipedia.org/wiki/Zeckendorf%27s_theorem#/media/File:Zeckendorf_representations_89px.svg

This suggests a dynamic programming algorithm. Construct a matrix with the height index representing Fibonacci numbers and the width index representing term counts. So, the (i,j) entry would indicate the number of Zeckendorf Reps starting with the ith Fibonacci number (sorted in descending order) and having j terms.

Because of the recursive structure seen in the visualization, for the most part, the nth row of this matrix is formed by summing a right-shifted copy of rows 1 through n-2 and placing a leading 1 in the first column. The last row is different in that some Zeckendorf Reps are for numbers that are too big. These must be ignored when creatting the last row.
'''

def one_zeros(length):
	'''Returns [1,0,0,0, ..., 0].'''
	a = [0] * length
	a[0] = 1
	return a

def shift_right(list, amount = 1):
	return ([0] * amount) + list[:-amount]

def vec_add(a, b):
	assert len(a) == len(b)
	return [a[i] + b[i] for i in range(len(a))]

def max_sum(fib, i):
	'''Max number having a Zeckendorf Rep starting with the ith Fibonacci number (sorted in descending order).'''
	return fib[i+1] - 1

# Used just for clarity's sake
def min_sum(fib, i):
	'''Min number having a Zeckendorf Rep starting with the ith Fibonacci number (sorted in descending order).'''
	return fib[i]

def solve(M):
	fib, last = [1, 2], 3
	while last < M:
		fib.append(last)
		last += fib[-2]

	N   = len(fib)
	mat = [one_zeros(N), one_zeros(N)]

	for i in range(2, N):
		base_sum = fib[i]
		level    = 1
		j, max_j = 0, i - 2

		mat.append(one_zeros(N))
		while j <= max_j:
			if base_sum + max_sum(fib, j) < M:
				mat[-1] = vec_add(mat[-1], shift_right(mat[j], level))
				j += 1
			elif base_sum + min_sum(fib, j) < M:
				# should only get here on the very last i
				mat[-1] = vec_add(mat[-1], shift_right(one_zeros(N), level))
				base_sum += fib[j]
				level    += 1
				j, max_j  = 0, j - 2
			else:
				break

	return sum(sum(m[i]*(i+1) for i in range(len(m))) for m in mat)

assert solve(10**6) == 7894453

print(solve(10**17))
